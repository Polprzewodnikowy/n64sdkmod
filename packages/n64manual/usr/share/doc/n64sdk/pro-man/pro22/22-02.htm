<html>
<head>
<link rel=stylesheet type="text/css" href="../../mobile/allman.css">
<title>Chapter 22 - Scheduling Audio and Graphics</title>
<!-- Editor: Paula W
      Notes: Added link to style-sheet, performed spell check. -->
</head>

<h1>22.2 Using the Scheduler</h1>

<p>The Scheduler is a host CPU thread that addresses the issues discussed above. It is responsible for executing audio and graphics tasks on the RCP so that host and RCP overrun is minimized or eliminated. </p>

<p>Each video retrace, the Scheduler reads the new tasks generated by client <A target="keywords" HREF="../../keywords/index/data/system.htm#thread">threads</A> from the task queue and adds them to the end of a real-time (audio) or non-real-time (graphics) task schedule list. </p>

<p>If the previous frame's graphics task has overrun, the Scheduler causes the task to yield. It then runs the next audio task, resuming the yielded task when the audio task has completely processed, and, if any, additional graphics tasks that are to be run in the current frame. </p>

<p>When a task completes, the Scheduler sends a <A target="keywords" HREF="../../keywords/index/data/system.htm#message">message</a> to the client indicating that the work it requested is complete. </p>

<p align="right"><a href="index.htm#index"><img alt="UP" src="../../gif/index.gif" border=0></a></p><hr>
<a name="01"><h2>22.2.1 Creating the Scheduler: <a href="../../n64man/os/osCreateScheduler.htm">osCreateScheduler()</a></h2></a>

<p>In order to use the Scheduler, you must first call <a href="../../n64man/os/osCreateScheduler.htm">osCreateScheduler()</a> to initialize the OSSched data structure, its message queues and the Vi Manager. The <a href="../../n64man/os/osCreateScheduler.htm">osCreateScheduler()</a> function spawns a thread to schedule and manage task execution. One of the parameters to this call is the thread priority, which should be higher than that of the threads which generate the command lists.</p>

<p align="right"><a href="index.htm#index"><img alt="UP" src="../../gif/index.gif" border=0></a></p><hr>
<a name="02"><h2>22.2.2 Adding Clients to the Scheduler: <a href="../../n64man/os/osScAddClient.htm">osScAddClient()</a></h2></a>

<p>The Scheduler instantiates the Vi Manager and receives all retrace messages. However, clients of the Scheduler can receive a copy of the retrace message by providing a message queue when they sign in. This is accomplished by calling the <a href="../../n64man/os/osScAddClient.htm">osScAddClient()</a> function. </p>

<p><strong>Note:</strong>  One of the parameters to <a href="../../n64man/os/osScAddClient.htm">osScAddClient()</a> is the message queue on which you wish to receive retrace messages. Make sure that the queue is big enough if you do not want to lose messages, as the Scheduler does not block when the queue is full. </p>

<p align="right"><a href="index.htm#index"><img alt="UP" src="../../gif/index.gif" border=0></a></p><hr>
<a name="03"><h2>22.2.3 Creating Scheduler Tasks:  OSScTask Structure</h2></a>

<p>In order to send tasks to the Scheduler for execution, you must first create and initialize an OSScTask structure. The structure and a description of its fields is listed below. </p>

<blockquote><pre>
typedef struct OSScTask_s{
        struct OSScTask_s   *next;
        s32                 state;
        u32                 flags;
        void                *framebuffer;

        OSTask              list;
        OSMesgQueue         *msgQ;
        OSMesg              msg;
}OSScTask;
</pre></blockquote>

<table border=1 align="center">
  <caption><a name="t22-01"><strong>Table 22-1 OSScTask structure fields</strong></a></caption>
  <tr><th>Field</th><th>Description</th></tr>
  <tr><td>next</td><td>Not used by client (used by the scheduler for list management). </td></tr>
  <tr><td>state</td><td>Not used by client (used by the scheduler for state management).</td></tr>
  <tr><td>framebuffer</td><td>Address of the frame buffer for this task (if it is a graphics task).</td></tr>
  <tr><td>list</td><td>Structure containing task code and command list data (described below).</td></tr>
  <tr><td>msgQ</td><td>The message queue on which the client is to receive the task done message.</td></tr>
  <tr><td>msg</td><td>The message that the client is to receive when the task in done.</td></tr>
  <tr><td>type</td><td>Task type: should be initialized to M_AUDTASK for audio tasks or M_GFXTASK for graphics tasks.</td></tr>
  <tr><td>flags</td><td>Various task state bits: should be initialized to 0 for audio tasks, or OS_TASK_DP_WAIT for most graphics tasks</td></tr>
  <tr><td>ucode_boot</td><td> Pointer to boot <A target="keywords" HREF="../../keywords/index/data/system.htm#microcode">microcode</a>
: should be initialized to <a href="../../n64man/ucode/rspboot.htm">rspboot</a>TextStart.</td></tr>
  <tr><td>ucode_boot_size</td><td>Pointer to boot microcode size in bytes: should be initialized to ((u32)rspbootTextEnd - (u32)rspbootTextStart).</td></tr>
  <tr><td>ucode</td><td>Pointer to task microcode: Should be set to one of gspFast3DTextStart, gspFast3D_dramTextStart, gspLine3DTextStart, or gspLine3D_dramTextStart for graphics tasks; otherwise aspMainTextStart for audio tasks.</td></tr>
  <tr><td>ucode_size</td><td>Size of microcode; should be initialized to SP_UCODE_SIZE.</td></tr>
  <tr><td>ucode_data</td><td>Pointer to task microcode. Should be set to one of gspFast3DDataStart, gspFast3D_dramDataStart, gspLine3DDataStart, or gspLine3D_dramDataStart for graphics tasks; otherwise aspMainDataStart for audio tasks.</td></tr>
  <tr><td>ucode_data_size</td><td>Size of microcode data; should be initialized to SP_UCODE_DATA_SIZE.</td></tr>
  <tr><td>dram_stack</td><td>Pointer to DRAM <a href="../../keywords/index/data/graphics.htm#matrix stack" target="keywords">matrix stack</a>: should be initialized to 0 for audio tasks, and for graphic tasks to memory region of size SP_DRAM_STACK_SIZE8 bytes.</td></tr>
  <tr><td>dram_stack_size</td><td>DRAM matrix stack size in bytes: should be initialized to 0 for audio tasks or SP_DRAM_STACK_SIZE8 for graphics tasks.</td></tr>
  <tr><td>output_buff</td><td>Pointer to output buffer. The &QUOT;_dram&QUOT;versions of the graphics microcode will route the SP output to DRAM rather than to the DP. When this microcode is used, this should point to a memory region to which the SP will write the DP command list.</td></tr>
  <tr><td>output_buff_size</td><td>Pointer to store output buffer length. The SP will write the size of the DP command list in bytes to this location.</td></tr>
  <tr><td>data_ptr</td><td>SP command list pointer. For graphics tasks, this is the application constructed <a href="../../keywords/index/data/graphics.htm#display list" target="keywords">display list</a>. For audio tasks, this command list is created by <a href="../../n64man/al/alAudioFrame.htm">alAudioFrame()</a>.</td></tr>
  <tr><td>data_size</td><td>Length of SP command list in bytes.</td></tr>
  <tr><td>yield_data_ptr</td><td>Pointer to buffer to store saved state of yielding task. If the application is going to support <A target="keywords" HREF="../../keywords/index/data/system.htm#preemption">preemption</A> of graphics tasks, the graphics tasks should have this structure member set. This should point to a memory region of size OS_YIELD_DATA_SIZE bytes. If task preemption is not supported by the application, this field be initialized to 0. Audio tasks should always set this field to 0.</td></tr>
  <tr><td>yield_data_size</td><td>Size of yield buffer in bytes. When task yielding is to be supported by the application, this should be initialized to OS_YIELD_DATA_SIZE for the graphics task. This should always be 0 for audio tasks.</td></tr>
</table>

<p><strong>Note:</strong>  Refer to the <a href="../../n64man/os/osSpTaskLoad.htm">osSpTaskLoad()</a> man page for information about the <A target="keywords" HREF="../../keywords/index/data/system.htm#alignment rule">alignment rule</A> of the data pointers.</p>

<p align="right"><a href="index.htm#index"><img alt="UP" src="../../gif/index.gif" border=0></a></p><hr>
<a name="04"><h2>22.2.4 Sending Tasks to the Scheduler: <a href="../../n64man/os/osScGetTaskQ.htm">osScGetTaskQ()</a></h2></a>

<p>Once you have created and initialized a Scheduler task, you can send it to the Scheduler thread via the Scheduler's task queue. You can obtain a pointer to this queue by calling <a href="../../n64man/os/osScGetTaskQ.htm">osScGetTaskQ()</a>.</p>

<p>The Scheduler will read this task queue after the next retrace message from the Vi Manager. Normally, you will send one audio and one graphics task to the Scheduler each frame. </p>

<p><strong>Note:</strong>  After you send the task to the Scheduler, you should not modify it until you receive the &QUOT;Done&QUOT; message. </p>
</p>


<p align="right"><a href="index.htm#index"><img alt="UP" src="../../gif/index.gif" border=0></a></p><hr>
</body> </html>
