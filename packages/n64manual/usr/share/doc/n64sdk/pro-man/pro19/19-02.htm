<html>
<head>
<link rel=stylesheet type="text/css" href="../../mobile/allman.css">
<title>Chapter 19 - Audio File Formats</title>
<!-- Editor: Paula W
      Notes: Added link to style-sheet, performed spell check. -->
</head>

<H1>
19.2 ADPCM AIFC Format</H1>
<p>The compressed ADPCM file format is based around <a href="../../keywords/index/data/audio.htm#AIFC" target="keywords">AIFC</a>. It uses a non-standard compression type and two application-specific chunks that contain the <a href="../../keywords/index/data/audio.htm#code book" target="keywords">codebook</a> and loop point information. This file is generated by the <a href="../../keywords/index/data/audio.htm#ADPCM" target="keywords">ADPCM</a> encoding tool from standard AIFC and <a href="../../keywords/index/data/audio.htm#AIFF" target="keywords">AIFF</a> sample files, and is used by the <a href="../../keywords/index/data/audio.htm#instrument compiler" target="keywords">Instrument Compiler</a> to generate <a href="../../keywords/index/data/audio.htm#bank file" target="keywords">Bank Files</a> and Table files. </p>

<P>As in AIFC, chunks are grouped together in a &QUOT;FORM&QUOT; container chunk: </p>
<BLOCKQUOTE>
<PRE>typedef struct {
        ID              ckID;           /* &QUOT;FORM&QUOT; */
        s32             ckDataSize;
        s32             formType;       /* &QUOT;AIFC&QUOT; */
        Chunk           chunks[]
}</PRE>
</BLOCKQUOTE>
<p>where ckID is always FORM and formType is AIFC. The standard AIFC chunks, which are essential, are the Common chunk, which contains information about the sound length; and the Sound data chunk. </p>
<BLOCKQUOTE>
<PRE>typedef struct {
        u32             ckID;                   /* &QUOT;COMM&QUOT; */
        S32             ckDataSize;
        s16             numChannels;
        u32             numSampleFrames;
        s16             sampleSize;
        extended        sampleRate;
        u32             compressionType;        /* &QUOT;VAPC&QUOT; */
        pstring         compressionName;        /* &QUOT;VADPCM ~ 4:1&QUOT; */
}</PRE>
</BLOCKQUOTE>

<p>The current format accepts only a single channel. The numSampleFrames field should be set to the number of bytes represented by the compressed data, not the the number of bytes used. The sampleRate is an 80 bit floating point number (see AIFC spec). 
</p>

<P>The Sound data chunk contains the compressed data:
<BLOCKQUOTE>
<PRE>typedef struct {
        u32             ckID;           /* &QUOT;SSND&QUOT; */
        s32             ckDataSize;
        u32             offset;
        u32             blockSize
        u8              soundData[];
}</PRE>
</BLOCKQUOTE>

<p>Both offset and blockSize are set to zero. </p>

<P>The encoded file will include two application-specific chunks. The common Application Specific data chunk format in AIFC is: 
<BLOCKQUOTE>
<PRE>typedef struct {
        u32             ckID;                           /* &QUOT;APPL&QUOT; */
        s32             ckDataSize;
        u32             applicationSignature;           /* &QUOT;stoc&QUOT; */
        u8              data[];
}</PRE>
</BLOCKQUOTE>

<p>where data[] contains the application-specific data. </p>

<P>The Codebook application-specific data define a set of predictors that are used in the decoding of the compressed ADPCM data. 
<BLOCKQUOTE>
<PRE>typedef struct {
        u16             version;        /* Should be 01 */
        s16             order;
        u16             nEntries;       /* &QUOT;stoc&QUOT; */
        s16             tableData[];
}</PRE>
</BLOCKQUOTE>
<p>The order and nEntries fields together determine the length of the tableData field. In the current implementation, order, which defines the ADPCM predictor order, must be 2. nEntries can be anything from 1 to 8. The length of the tableData field is order*nEntries*16 bytes. </p>

<P>The Loop application-specific data contains information necessary to allow the ADPCM decompresser to loop a sound. It has the following structure: </p>
<BLOCKQUOTE>
<PRE>typedef struct {
        u16             version;        /* Should be 01 */
        s16             nLoops;
        adpcmLoop       loopData[];
}</PRE>
</BLOCKQUOTE>
<p>nLoops defines the number of loop points and hence the number of adpcmLoop structures in the chunk. In the current library, only one loop point can be specified. loopData has the following structure: </p>
<BLOCKQUOTE>
<PRE>typedef struct {
        u16             state[16];
        s32             start;
        s32             end;
        s32             count;
} adpcmLoop</PRE>
</BLOCKQUOTE>
<p>state defines the internal state of the ADPCM decoder at the start of the loop and is necessary for smooth playback across the loop point. The start and end values are represented in number of samples. count defines the number of times the loop is played before the sound completes. Setting count to -1 indicates that the loop should play indefinitely. </p>

<DIV ALIGN=right><A HREF="index.htm#index"><IMG SRC="../../gif/index.gif" ALT="UP" BORDER=0 ></A></DIV>

<HR>
</BODY>
</HTML>
