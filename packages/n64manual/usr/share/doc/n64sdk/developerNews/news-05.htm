<!DOCTYPE HTML PUBLIC "-//IBM//DTD HPB HTML//EN">
<HTML>
<HEAD>
<TITLE>Developers News 1.5</TITLE>
</HEAD>

<BODY bgcolor="#FFFFFF">
<font face="arial" size="-1">

<HR>
<P align="center">
<FONT size="6"><STRONG><IMG src="gif/devnews.gif" height="44" width="453">1.5</STRONG></FONT>
</P>

<P>
Bug information and programming guides for the N64 will be periodically released.  All information that will become unnecessary with software (library, etc.) and hardware upgrades used in development will be noted together.  Please utilize this information after confirming that the information concerns your specific upgrade. 
</P>

<b><A name="top">Contents:</A></b>

<ol>
<li><A href="#p1">Reset Processing</A>
<li><A href="#p2">Processing Flow During Reset</A>
<li><A href="#p3">Precautions</A>
<li><A href="#p4">About pre-NMI Processing</A>
<li><A href="#p5">Sample of pre-NMI Processing</A>
</ol>
<HR>
<A name="p1">1. Reset Processing</A>
<P>
There are two types of reset used in the Nintendo 64. Cold Reset is accomplished by cycling the power OFF and ON, while NMI (non-maskable interrupt) Reset is generated by pressing the RESET button. This document describes the processing methods for resetting the system using NMI. 
</P>
<P>
There are actually 3 reset methods which can be used with the R4000 Series: cold reset, soft reset and NMI, but soft reset is not supported by the Nintendo 64. </P>
<P align="right">
<A href="#top"><IMG src="../gif/index.gif" height="17" width="65" border="0"></A>
</P>
<HR>
<A name="p2">2. Processing Flow During Reset</A>
<P>
The processing flow when the user presses the RESET button is as follows. 
</P>
<OL>
  <LI>Press RESET button
  <LI>pre-NMI is generated
  <LI>pre-NMI processing
  <LI>NMI is generated
  <LI>CPU goes to reset vector
  <LI>CPU executes boot program
</OL>
<P>
The time from Pre-NMI generation to NMI generation is 0.5 seconds or more.</P>
<P>
That is, if the finger is removed from the RESET button within 0.5 seconds, this time duration will be 0.5 seconds. However, if the button is continuously pressed for more than 0.5 seconds, the reset time will continue until immediately after the finger is removed (i.e., if the button is continuously pressed for 1 second, reset time will be 1 second). 
</P>
<P>
There is no RESET switch on the current emulation boards, but a pseudo-NMI can be generated by executing a RESET program. 
</P>
<P>
On the other hand, PARTNER-N64 has a switch to reset, however, it is not possible for the software to issue NMI.</P>
<P>
It is expected to be improved near future.
</P>
<P align="right">
<A href="#top"><IMG src="../gif/index.gif" height="17" width="65" border="0"></A>
</P>
<HR>
<A name="p3">3. Precautions</A>
<P>
NMI's are generated by the PIf. The PIf's job is primarily to perform the processing for mechanisms which use a serial interface, such as the Controller.
</P>
<P>
Consequently, in cases
where the CPU is constantly monitoring the Controller, there are instances in which the PIF will be BUSY and RESET generation will be delayed. 
</P>
<P>
This creates no problems as long as Controller data are read one time per frame. 
</P>
<P>
In addition, the NMI wait time on current emulation boards is 0.5 seconds or more (around several seconds). 
</P>
<P align="right">
<A href="#top"><IMG src="../gif/index.gif" height="17" width="65" border="0"></A>
</P>
<HR>
<A name="p4">4. About pre-NMI Processing</A>
<P>
If the PIf load is at a normal level, a pre-NMI is generated at the time the RESET switch is pressed. The minimum processing that must be performed at the time of the pre-NMI is comprised of the following 4 items: 
</P>
<OL type="a">
  <LI> Stop GFX task
  <LI> Stop audio task
  <LI> Don't issue a new PI DMA
  <LI> Return YScale value to 1(<A href="../n64man/os/osViSetYScale.htm">osViSetYScale(1)</A>), if it has been modified.
</OL>
<P>
In other words, all RCP processing is stopped. When 64DD is used, it must also be reset. 
</P>

<P>
Next, why these per-NMI processing is necessary will be explained.
</P>
<P>
An NMI signal is generated in the Nintendo 64 only for the CPU. No RESET signal is input to the RCP. This is because it is difficult to forcibly terminate graphic and sound tasks which are currently being executed without giving the user an uneasy feeling.
</P>
<P>
Therefore, if processing in the RCP is not terminated after the pre-NMI is generated, processing in the RCP will continue to be executed even after a RESET. In the worst case, this will have a detrimental effect on the CPU's boot sequence, inevitably causing the CPU to hang up.
</P>
<P>
In order to avoid this situation, it is necessary to terminate any processing
being executed in the RCP after a pre-NMI has been generated. 
</P>
<P align="right">
<A href="#top"><IMG src="../gif/index.gif" height="17" width="65" border="0"></A>
</P>
<HR>
<A name="p5">5. Sample of pre-NMI Processing</A>
<P>
In the following example, a sample source code "simple" has been partially modified. 
</P>
<P>
Each thread senses the generation of a pre-NMI by means of an OS_EVENT_PRENMI message, and the necessary processing is performed. 
</P>
<OL type="a">
  <LI>Stopping GFX task
</OL>
<BLOCKQUOTE>

<HR>
</BLOCKQUOTE>
<BLOCKQUOTE>

<PRE>
<font face="courier" size="2">
static void gameproc(void *argv)
{
    ...

    while (1)
    {
        ...

        switch (msg-&gt;gen.type)
        {
            ...

            if (pendingGFX gen.type)
            {

            ...

            case (OS_SC_PRE_NMI_MSG):
              /* what should we really do here? quit? ramp down volume? */
              <A href="../n64man/al/alSeqpStop.htm">alSeqpStop</A>(seqp);
              <A href="../n64man/al/alSeqpDelete.htm">alSeqpDelete</A>(seqp);
              done = 1;
              break;

              ...

	    }
        }
    }

    <A href="../n64man/al/alClose.htm">alClose</A>(&amp;__am.g);
}
</font>
</PRE>
</BLOCKQUOTE>
<P>
It is possible to stop sound in the same way as graphics by not performing any new processing after generating a pre-NMI. In the above case, the procedure 
</P>
<BLOCKQUOTE>

<PRE>
<font face="courier" size="2">
<A href="../n64man/al/alSeqpStop.htm">alSeqpStop</A> -&gt; <A href="../n64man/al/alSeqpDelete.htm">alSeqpDelete</A>
</font>
</PRE>
</BLOCKQUOTE>
<P>
was used because a standard MIDI sequence player is being used, but if a compact MIDI player is being used, sound would be stopped using the procedure
</P>
<BLOCKQUOTE>

<PRE>
<font face="courier" size="2">
<A href="../n64man/al/alCSPStop.htm">alCSPStop</A> -&gt; <A href="../n64man/al/alCSPDelete.htm">alCSPDelete</A>
</font>
</PRE>
</BLOCKQUOTE>
<P>
while if synthesizer voice is being used by a sound effect, the sound effect would be stopped using the procedure </P>
<BLOCKQUOTE>

<PRE>
<font face="courier" size="2">
<A href="../n64man/al/alSynStopVoice.htm">alSynStopVoice</A> -&gt; <A href="../n64man/al/alSynDelete.htm">alSynDelete</A> 
</font>
</PRE>
</BLOCKQUOTE>
<P>
(however, <A href="../n64man/al/alSynDelete.htm">alSynDelete</A> cannot be implementedat the current time.)
</P>
<P>
Caution is required when using <A href="../n64man/al/alSeqpDelete.htm">alSeqpDelete</A> and <A href="../n64man/al/alCSPDelete.htm">alCSPDelete</A>, since there is a system anomaly in the N64 OS up to revision 2.0e which makes it possible that the interrupt would continue to be masked.
</P>
<P>
Because of this, either use patch 1.01, or use OS 2.0g or later, when using these functions. 
</P>
<P>
Processing is also possible which gradually diminishes the sound in the same way as the screen by decreasing the volume in a stepwise fashion. However, stop the execution of new audio tasks when the volume reaches 0. 
</P>
<P align="right">
<A href="#top"><IMG src="../gif/index.gif" height="17" width="65" border="0"></A>
</P>
<HR>

</font>
</BODY>
</HTML>
