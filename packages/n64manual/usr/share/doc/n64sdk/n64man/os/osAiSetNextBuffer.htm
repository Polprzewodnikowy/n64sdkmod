<!DOCTYPE HTML PUBLIC "-//IBM//DTD HPB HTML//EN">
<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../N64man.css">
<Editor's Notes: JLR made reformating and copy edits.
  PWC- updated formatting
  MAP- added links, updated format
-->
<TITLE>osAiSetNextBuffer</TITLE>
</HEAD>

<BODY bgcolor="#FFFFFF">
<font style="font-size: 12pt"><b>osAiSetNextBuffer</b></font><font style="font-size: 9pt"><b> (function)</b></font>

<P>
osAiGetStatus, osAiGetLength, osAiSetFrequency, osAiSetNextBuffer</p>

<p><i>AI (audio interface) function</i>
</P>
<h3>Syntax</h3>
<p>
<BLOCKQUOTE>
<PRE>
#include &lt;ultra64.h&gt;     /* <A HREF="../../header/ultra64.htm">ultra64.h</A> */
u32 osAiGetStatus(void);
u32 osAiGetLength(void);
s32 osAiGetFrequency(u32 frequency);
s32 osAiSetNextBuffer(void *vaddr, u32 nbytes);</PRE></BLOCKQUOTE></p>

<h3>Description</h3>
<P>
These routines provide basic control for the AI (audio interface).
</P>
<P>
<a href="osAiGetStatus.htm">osAiGetStatus</a> returns the hardware status of the audio interface. In this 32-bit value, only bits AI_STATUS_FIFO_FULL and AI_STATUS_DMA_BUSY contain useful information. AI_STATUS_FIFO_FULL is set when both audio DMA registers have been programmed. AI_STATUS_DMA_BUSY is set when DMA is in progress. 
</P>
<P>
Based on the input requested frequency (in Hz), the <a href="osAiSetFrequency.htm">osAiSetFrequency</a> function calculates the correct values for the internal divisors and returns the actual frequency generated by these divisors. The requested frequency should fall between 3000 Hz and 368000 Hz on NTSC systems, or between 3050 Hz and 376000 Hz on PAL systems. 
</P>
<P>
<tt>osAiSetNextBuffer</tt> sets up the next DMA transfer from RDRAM to the audio interface buffer. The vaddr argument points to the buffer in RDRAM, and the nbytes argument specifies the number of bytes to transfer. Note that the buffer address vaddr must be 64-bit aligned and that nbytes must be a multiple of 8 bytes. A maximum transfer size of 262144 bytes is supported. If the interface is busy (that is, AI_STATUS_FIFO_FULL is set), <tt>osAiSetNextBuffer</tt> returns -1 and stops the DMA operation.
</P>
<P>
<a href="osAiGetLength.htm">osAiGetLength</a> returns the number of bytes remaining in the current DMA buffer. 
</P>
<h3>Note</h3>
<P>
For hardware version 1.0, the audio DMA length register is only 15-bit long and thus supports a maximum transfer size of 32 Kbytes. In the final release, this register is extended to 18 bits to support a transfer of 256 Kbytes. 
</P>

<h3>Known Issue</h3>
<P>
It is worth noting that a previous hardware bug has been fixed by a software patch in osAiSetNextBuffer. This bug occurred when the address of the end of the buffer specified by <tt>osAiSetNextBuffer</tt> was at a specific value. This value occurred when the following was true:
</P>
<BLOCKQUOTE>

<PRE>
(vaddr + nbytes) &amp; 0x00003FFF == 0x00002000
</PRE>
</BLOCKQUOTE>
<P>
(when the buffer ends with address of lower 14 bits 0x2000) In this case, the DMA transfer does not complete successfully. This can cause clicks and pops in the audio output. This bug no longer requires special handling by the application because it is now patched by <tt>osAiSetNextBuffer</tt>. 
</P>
<h3>See Also</h3>
<P>
<A HREF="../os/osAiGetStatus.htm">osAiGetStatus</A>, 
<A HREF="../os/osAiGetLength.htm">osAiGetLength</A>, 
<A HREF="../os/osAiSetFrequency.htm">osAiSetFrequency</A>, and 
<A href="osTvType.htm">osTvType</A>
</P>
<h3>Revision History</h3>
<p>1999/04/30  Changed Format</p>
<br><br>


</BODY>
</HTML>
