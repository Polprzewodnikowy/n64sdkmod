<!DOCTYPE HTML PUBLIC "-//IBM//DTD HPB HTML//EN">
<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../N64man.css">
<Editor's Notes: JLR made reformating and copy edits.
  PWC- updated formatting
  MAP- added links, updated format
-->
<title>osAiSetFrequency</title>
</head>

<body bgcolor="#FFFFFF">
<font style="font-size: 12pt"><b>osAiSetFrequency</b></font><font style="font-size: 9pt"><b> (function)</b></font>

<p>osAiGetStatus, osAiGetLength, osAiSetFrequency,
osAiSetNextBuffer</p>

<p><i>Functions as AI (audio interface) function</i></p>

<h3>Syntax</h3>
<p>
<blockquote>
    <pre>#include &lt;ultra64.h&gt;     /* <A HREF="../../header/ultra64.htm">ultra64.h</A> */
u32 osAiGetStatus(void);
u32 osAiGetLength(void);
s32 osAiGetFrequency(u32 frequency);
s32 osAiSetNextBuffer(void *vaddr, u32 nbytes);</pre>
</blockquote>
</p>
<h3>Description</h3>

<p>These routines provide basic control for the AI (audio interface).</p>

<p><a href="osAiGetStatus.htm">osAiGetStatus</a> returns the hardware status of the audio interface. In this 32-bit value, only bits AI_STATUS_FIFO_FULL and AI_STATUS_DMA_BUSY contain useful information. AI_STATUS_FIFO_FULL is set when both audio DMA registers have been programmed. AI_STATUS_DMA_BUSY is set when DMA is in progress. </p>

<p>Based on the input requested frequency (in Hz), the <tt>osAiSetFrequency</tt> function calculates the correct values for the internal divisors and returns the actual frequency generated by these divisors. The requested frequency should fall between 3000 Hz and 368000 Hz on NTSC systems, or between 3050 Hz and 376000 Hz on PAL systems. </p>

<p><a href="osAiSetNextBuffer.htm">osAiSetNextBuffer</a> sets up the next DMA transfer from RDRAM to the audio interface buffer. The vaddr argument points to the buffer in RDRAM, and the nbytes argument specifies the number of bytes to transfer. Note that the buffer address vaddr must be 64-bit aligned and that nbytes must be a multiple of 8 bytes. A maximum transfer size of 262144 bytes is supported. If the interface is busy (that is, AI_STATUS_FIFO_FULL is set), <tt>osAiSetNextBuffer</tt> returns -1 and stops the DMA operation.</p>

<p><a href="osAiGetLength.htm">osAiGetLength</a> returns the number of bytes remaining in the current DMA buffer. </p>

<h3>Note</h3>

<p>For hardware version 1.0, the audio DMA length register is only 15-bit long and thus supports a maximum transfer size of 32 Kbytes. In the final release, this register is extended to 18 bits to support a transfer of 256 Kbytes. </p>

<h3>See Also</h3>

<p><A HREF="../os/osAiGetStatus.htm">osAiGetStatus</A>, 
<A HREF="../os/osAiGetLength.htm">osAiGetLength</A>, 
<A HREF="../os/osAiSetNextBuffer.htm">osAiSetNextBuffer</A>, and
<a href="osTvType.htm">osTvType</a></p>
<h3>Revision History</h3>
<p>1999/04/30  Changed Format</p>
<br><br>

</body>
</html>
