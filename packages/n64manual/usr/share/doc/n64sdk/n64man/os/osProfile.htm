<!DOCTYPE HTML PUBLIC "-//IBM//DTD HPB HTML//EN">
<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../N64man.css">
<Editor's Notes: JLR made reformating and copy edits
MAP- added links, updated format>
<title>osProfile</title>
</head>

<body bgcolor="#FFFFFF">
<font style="font-size: 12pt"><b>osProfile</b></font><font style="font-size: 9pt"><b> (function)</b></font>

<p>osProfileInit, osProfileStart, osProfileStop,
osProfileFlush</p>

<p><i>Run time profile for text spaces without shared sources</i></p>

<h3>Syntax</h3>
<p>
<blockquote>
    <pre>#include &lt;ultra64.h&gt;     /* <A HREF="../../header/ultra64.htm">ultra64.h</A> */
void osProfileInit(OSProf *profp, u32 profcnt);
void osProfileStart(u32 microseconds);
void osProfileStop(void);
void osProfileFlush(void);</pre>
</blockquote></p>

<h3>Description</h3>

<p>Profiling provides CPU-use statistics by profiling the amount of CPU time expended by a program in disjoint text spaces.</p>

<p>Profiling generates the statistics by creating an execution histogram for a current process. The histogram is defined for a list of regions of program code to be profiled specified by members of the profp array: profp[0], profp[1], ..., profp[profcnt-1]. The host-side application <A HREF="../tool/gperf.htm">gperf</A> copies the histogram data to the host and prints a report detailing the relative time spent processing each function. </p>

<p>The OSProf data structure has the following elements: </p>
<p>
<dl>
    <dt><strong>u16 *histo_base</strong></dt>
    <dd>Pointer to an array of u16 counters.<br>
        <br>
        </dd>
    <dt><strong>u32 histo_size</strong></dt>
    <dd>Number of counters in the histo_base buffer. Profiling requires one counter for each 32-bit word in the segment. <br>
        <br>
        </dd>
    <dt><strong>u32 *text_start</strong></dt>
    <dd>Pointer to the first instruction in the segment to be profiled. <br>
        <br>
        </dd>
    <dt><strong>u32 *text_end</strong></dt>
    <dd>Pointer to the last instruction in the segment to be profiled.<br>
        <br>
        </dd>
</dl></p>

<p>Each OSprof entry specifies a region of text space that needs to be profiled. If an instruction falls outside the bounds specified by the profp array, an internal 32-bit overflow counter is incremented.</p>

<p>The <a href="osProfileInit.htm">osProfileInit</a> function initializes the profiled segment count buffers and starts an IO thread that communicates profile data to the host when requested by the gperf tool. To use it, pass a pointer to an array of OSProf structures (profp) each element of which describes a segment to be profiled. The <b>profcnt</b> argument indicates the number of profiled segments. The <tt>osProfileInit</tt> function clears the counters for each profiled segment. A thread is started to service requests for profile data from the gperf tool. Profiling data can be dumped to the host any time after osProfileInit is called. Call osProfileInit before calling any other profiler function. </p>

<p>The <a href="osProfileStart.htm">osProfileStart</a> function is called to start the profiler's interval counter. The microseconds argument sets the period of this timer; A typical value is 10000 microseconds (10 milliseconds). The minimum timer period is defined by PROF_MIN_INTERVAL. Each time an interrupt is generated by the counter, the profiler determines which profiled segment the PC belongs to and then increments the proper counter in the counter buffer for that segment. If the PC does not lie within any profiled segment, an internal overflow register is incremented. There is no protection for counter overflow.</p>

<p>The <a href="osProfileStop.htm">osProfileStop</a> function is called to turn off profiling. Profiling data remains in memory but is not incremented further. The thread started by osProfileInit to send profile data to the host continues to run. You can call it again to resume profiling. </p>

<p>The <a href="osProfileFlush.htm">osProfileFlush</a> function can be used to programmatically transfer profile data to the gperf program assuming the gperf program is running in server mode. gperf program can also send requests to the profiler's IO thread at any time while the program is executing in non-server mode. </p>

<p>The following errors are reported when you are using the debug library:</p>
<p>
<dl>
    <dt><strong>ERR_OSPROFILEINIT_STR</strong></dt>
    <dd>Profile counter is running, call osProfileStop before initializing. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILEINIT_CNT</strong></dt>
    <dd>The profcnt argument is an illegal value. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILEINIT_ALN</strong></dt>
    <dd>The histo_base pointer must be 32-bit aligned. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILEINIT_ORD</strong></dt>
    <dd>The text_start element of the OSProf structure is greater than or equal to the text_end element. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILEINIT_SIZ</strong></dt>
    <dd>The histo_size element of the OSProf structure is an illegal size. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILESTART_TIME</strong></dt>
    <dd>The microseconds argument is less than PROF_MIN_INTERVAL. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILESTART_FLAG</strong></dt>
    <dd>Profiling has already been started. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILESTOP_FLAG</strong></dt>
    <dd>Profiling has already been stopped. <br>
        <br>
        </dd>
    <dt><strong>ERR_OSPROFILESTOP_TIMER</strong></dt>
    <dd>No profile timer to stop.<br>
        <br>
        </dd>
</dl></p>

<h3>Note</h3>

<ul>
    <li>Call the <tt>osProfileFlush</tt> function when gperf results an unexpected error or is too slow to be executed.
        <br>
        <br>
        </li>
    <li>The gperf tool (and thus profiling) does not work with programs that have functions that have been rearranged in the executable objects for optimization.<br>
        <br>
        </li>
    <li>Currently, profiling only supports 16-bit counters.
        <br>
        <br>
        </li>
    <li>Profiling is not available in the libultra_rom library.
        <br>
        <br>
        </li>
    <li>There is no check for overlapping text segments in the OSProf array. 
        <br>
        <br>
        </li>
</ul>

<h3>See Also</h3>

<p><a href="../tool/gperf.htm">gperf</a> and <a
href="../tool/makerom.htm">makerom</a>
</p>
<H3>Revision History</H3>
<P>
1999/04/30 Changed format
</P>

</body>
</html>
