<!DOCTYPE HTML PUBLIC "-//IBM//DTD HPB HTML//EN">
<HTML>
<HEAD>
<LINK REL=STYLESHEET TYPE="text/css" HREF="../N64man.css">
<!--
Editors Notes:
  PWC- updated formatting
-->
<TITLE>gspFast3D</TITLE>
</HEAD>

<BODY bgcolor="#FFFFFF">

<H1>gspFast3D</H1>
<P>
<i>Changed to the high compatible F3DEX microcode</i>
</P>
<H2>Function</H2>
<P>
<STRONG>gspFast3D, gspFast3D.dram, gspFast3D.fifo, gspF3DNoN, gspF3DNoN.dram,
gspF3DNoN.fifo </STRONG>
</P>
<P>
<i>High-quality 3D polygonal geometry RSP microcode</i>
</P>
<H2>Description</H2>
<P>
This is the optimized, high-quality, full-featured 3D polygonal geometry RSP microcode.
</P>
<P>
 It supports 3D clipping, lighting, texture coordination generation, fog, and matrix stack.
</P>
<P>
The DRAM version of the microcode directs the output (RDP display list) to a memory buffer (DRAM), not to the RDP.
</P>
<P>
The fifo version of the microcode uses memory buffer (RDRAM) as FIFO, and transfers the RDP display list to RDP.
</P>
<P>
gspFast3D, gspFast3D.dram, and gspFast3D.fifo versions of microcode are equivalent to gspF3DNoN, gspF3DNoN.dram, and gspF3DNoN.fifo versions, respectively. The only difference is that the former versions performs clipping in near clipping while the latter versions perform clipping in eyepoint. (See <A href="#NearClipping">Note for Near Clipping</A>)
</P>
<P>
All computations are performed with as much precision as is practical, in order to create the highest quality images</P>
<H2>GBI</H2>
<P>
The following GBI commands are not supported by this microcode.
</P>
<BLOCKQUOTE>

<PRE>
gSPLine3D
</PRE>
</BLOCKQUOTE>
<P>
All <A href="../gsp/gSPLine3D.htm">gSPLine3D</A> are compiled as noop, and they don't affect at all.
</P>
<H2>Performance</H2>
<P>
In order from the fastest to the slowest, the following types of triangles can be generated by this microcode: 
</P>
<BLOCKQUOTE>

<PRE>
Filled Flat Shaded (must set primitive color in DP appropriately)
Gouraud Shaded
Gouraud Shaded, Z-buffered
Gouraud Shaded, Textured
Gouraud Shaded, Textured, Z-bufferd
</PRE>
</BLOCKQUOTE>
<P>
Triangle attribute computation is heavily vectorized, so generation of Gouraud shading attributes is essentially free, if you are generating any other attributes.
</P>
<P>
Vertex transformations and lighting calculations are heavily vectorized, so it is best to operate on as many vertices as possible. Even number-sized loads are more efficient because vertices are processed in groups of two.
</P>
<P>
When doing lighting, and any vertices are clipped, clipping and lighting are implemented as ucode overlays, using a most recently used algorithm. Lighting happens at vertex load time and clipping happens at triangle draw time, so this division of microcode is acceptable. However, a display list that loads only a few vertices at a time and then draws a small number of triangles, would not amortize the microcode swapping overhead very effectively.
</P>
<P>
The RCP is designed to draw high quality textured primitives. Where possible, use texture-mapping to achieve visual complexity rather than additional geometry.
</P>
<u><B>Notes on Different Versions</B></u><BR><BR>
<P>
There are some differences when calling the DRAM and fifo versions of this microcode.
</P>
<DL>
  <DT><STRONG>gspFast3D:</STRONG>
  <DD>The flags field of any task followed by this task should have OS_TASK_DP_WAIT set. If more than one task using this microcode is called in the same frame, then only the last task should contain a <A href="../gdp/gDPFullSync.htm">gDPFullSync</A> in its display list. This microcode takes care of sending all output to the RDP. When using this microcode, it is not necessary to specify output_buff or an output_buff_size. (These fields of task header can be set to 0.)
</DL>
<DL>
  <DT><STRONG>gspFast3D.dram:</STRONG>
  <DD>Tasks using this microcode need to set the OS_TASK_DP_WAIT flag only if they follow a task using gspFast3D or gspFast3D.fifo. This microcode sends its data to a buffer in DRAM and not to the RDP. The CPU must then cause the buffer to be sent to the RDP. The buffer is pointed to by output_buff in the task header. This must point to a buffer which is at least as big as the maximum RDP display list that can be generated by the task. Remember that when geometry gets clipped RDP lists will expand, so leave extra room. If the buffer is not large enough to store the entire RDP display list, other memory areas will be overwritten. After the RSP finishes its process, the buffer can be sent to the RSP using the <A href="../os/osDpSetNextBuffer.htm">osDpSetNextBuffer</A> command. The length of data in the buffer, which is needed for <A href="../os/osDpSetNextBuffer.htm">osDpSetNextBuffer</A>, is written at an address specified by rdp_output_len in the task header. While the display list is being sent to the RDP, the RSP can execute other DRAM microcode, whose output_buff is different, or audio tasks. When <A href="../gdp/gDPFullSync.htm">gDPFullSync</A> is not included in the display list to be sent to the RDP, other RDP display lists can be sent (from the RSP task to other buffers) using other <A href="../os/osDpSetNextBuffer.htm">osDpSetNextBuffer</A> commands. However, when <A href="../gdp/gDPFullSync.htm">gDPFullSync</A> is included in the display list, neither send other RDP display lists using <A href="../os/osDpSetNextBuffer.htm">osDpSetNextBuffer</A> nor start gspFast3D or gspFast3D.fifo tasks until completing the display list.
</DL>
<DL>
  <DT><STRONG>gspFast3D.fifo:</STRONG>
  <DD>A task that uses this microcode and is followed by a gspFast3D task or a <A href="../os/osDpSetNextBuffer.htm">osDpSetNextBuffer</A> command needs to set the OS_TASK_DP_WAIT flag. This microcode watches transmission of the display list to the RDP. A buffer specified by output_buf in the task header is used. The buffer must be cache aligned. Output_buff_size must be the pointer for byte followed by last byte of the buffer. The larger the buffer is, the more practical the interface between the RSP and the RDP. When there are multiple tasks in parallel which use fifo microcode, only the last task in a frame must include <A href="../gdp/gDPFullSync.htm">gDPFullSync</A>. There are multiple tasks continuously which use fifo microcode, all tasks must use the one particular output_buff buffer. (Each task can use a different buffer, however, it is more efficient to use one large buffer for all tasks.)
</DL>
<H2><A name="NearClipping"></A>Note for Near Clipping</H2>
<P>
Near Clipping removes geometry either behind the viewer or between the viewer and the Near Clipping plane. In actual circumstances, an object never disappears when getting closer to the viewpoint, so it should not happen in a N64 program. One way to achieve this is to locate the near plane very close to the viewpoint. (By calling <A href="../gu/guPerspective.htm">guPerspective</A>, make the near value small.) However, it does not always work because the smaller ratio of near/far makes the accuracy of Z and texture mapping worse. Another way to accomplish this is to use a gspF3DNoN microcode (or its DRAM or fifo version) which does Near Clipping. An object behind the viewer is clipped and an object far from the near plane is visible. However, an object between the near plane and the viewer is also visible. In this way, the near value can be increased without geometry disappearing between the viewpoint and the near plane. Z buffering never functions in the area between the viewpoint and the near plane. As a result, objects between the near plane and viewer never hide each other. For example, in an asteroid type game, when an asteroid approaches the view point closer than the near plane, the asteroid is drawn correctly. (objects far from the near plane are hidden.) However, when two asteroids approach closer than the near plane, they cannot be hidden correctly.
</P>
<H1>Default RDP State</H1>
<P>
Whenever a graphic task is first started, some of the RDP states are initialized to their default states. The rest of the states keep their previous values. After restarting from yield, RDP states are restored with states set at yield. The following are RDP default settings: 
</P>
<UL>
  <LI>gsDPSetAlphaCompare(G_AC_NONE)
  <LI>gsDPSetDepthSource(G_ZS_PIXEL)
  <LI>gsDPSetRenderMode(RM_NOOP, RM_NOOP2)
  <LI>gsDPSetAlphaDither(G_AD_DISABLE)
  <LI>gsDPSetColorDither(G_CD_DISABLE)
  <LI>gsDPSetCombineKey(G_CK_NONE)
  <LI>gsDPSetTextureConvert(G_TC_FILT)
  <LI>gsDPSetTextureFilter(G_TF_POINT)
  <LI>gsDPSetTextureLUT(G_TT_NONE)
  <LI>gsDPSetTextureLOD(G_TL_NONE)
  <LI>gsDPSetTextureDetail(G_TD_CLAMP)
  <LI>gsDPSetTexturePersp(G_TP_PERSP)
  <LI>gsDPSetCycleType(G_CYC_1CYCLE)
  <LI>gsDPPipelineMode(G_PM_NPRIMITIVE)
</UL>
<H2>Known Issue</H2>
<P>
None
</P>
<H2>See Also</H2>
<P>
<A href="gspLine3D.htm">gspLine3D</A>, <A href="gspTurbo3D.htm">gspTurbo3D</A>, <A href="../os/osSpTaskStart.htm">osSpTaskStart</A>
</P>
</BODY>
</HTML>
